## Run Code in Kestra

Kestra is very versatile and langauge-agnostic. It allows you to write your business logic with your preferred language and run it in a Docker container.

### Run Python Code in Kestra

In the previous section, we've already built a simple task that runs Python code in Kestra which basically uses a container through `io.kestra.plugin.scripts.python.Script`.

There are different ways to run Python code in Kestra. We will show two of them and how to exchange data between tasks.

ðŸ‘‰ More info about [Python in Kestra](https://kestra.io/docs/how-to-guides/python).

#### Option 1: Simple Inline Python Script

As seen before, you can run Inline Python code in Kestra in the script property.

You can also specify output files and run code before running the script:

1. Install `Pandas` before the running commands.
1. Run a script that calculates the new salary after a 10% raise for each employer. 
1. Then write the dataframe into a CSV file `output.csv`.

You can access the ouput file through: `Outputs` > `process_data` (task ID) > `outputFiles` > `output.csv` (see image below).

![Generated output CSV file](/images/output-csv.png)

#### Option 2: Using Namespace Files

Inline Python scripts work for small code pieces and trying things out. For more serious tasks, it's prefered to maintain the Python code outside of the task and Flow.

You can accomplish this separation via Namespace files.

Here is how to do it:

1. In Kestra UI, go to your namespace (e.g. `dev.testing`) with: `Namespaces` > `dev` > `testing`.
1. Click on `Files`.
1. Create a file called `2_1` and paste the following code:
```python
import pandas as pd

def process_sales_data():
    # Create sample sales data
    data = {
        'product': ['Widget', 'Gadget', 'Doohickey'],
        'quantity': [100, 150, 200],
        'price': [10.0, 20.0, 15.0]
    }
    df = pd.DataFrame(data)
    
    # Calculate revenue
    df['revenue'] = df['quantity'] * df['price']
    
    # Save results
    df.to_csv('sales_report.csv', index=False)
    
    # Return summary
    total_revenue = df['revenue'].sum()
    return f"Total revenue: ${total_revenue:,.2f}"

if __name__ == "__main__":
    result = process_sales_data()
    print(result)
```

> [!NOTE]
> You can also create folder structures to improve maintainability and add a better structure.

4. Create a new flow that uses this namespace file:
```yaml
id: python-with-namespace-files
namespace: dev.testing

tasks:
  - id: run_script
    type: io.kestra.plugin.scripts.python.Commands
    namespaceFiles:
      enabled: true
    beforeCommands:
      - pip install pandas
    outputFiles:
      - "sales_report.csv"
    commands:
      - python process_sales_data.py
```

### Exchange Data Between Tasks

The flows we looked at so far had a single tasks. However, you may want to chain multiple small modular tasks that run sequentially. That often requires to share data between these tasks.

Here is an example that shares data between two tasks:
```yaml
id: python-multi-step
namespace: dev.testing

tasks:
  - id: generate_data
    type: io.kestra.plugin.scripts.python.Script
    outputFiles:
      - "data.csv"
    script: |
      import csv
      
      # Generate data
      data = [
          ['name', 'score'],
          ['Alice', '85'],
          ['Bob', '92'],
          ['Charlie', '78']
      ]
      
      with open('data.csv', 'w', newline='') as f:
          writer = csv.writer(f)
          writer.writerows(data)
      
      print("Data generated successfully")
  
  - id: analyze_data
    type: io.kestra.plugin.scripts.python.Script
    beforeCommands:
      - pip install pandas
    inputFiles:
      data.csv: "{{ outputs.generate_data.outputFiles['data.csv'] }}"
    outputFiles:
      - "summary.txt"
    script: |
      import pandas as pd
      
      # Read the data from previous step
      df = pd.read_csv('data.csv')
      
      # Calculate statistics
      avg_score = df['score'].mean()
      max_score = df['score'].max()
      
      print(f"Average score: {avg_score:.2f}")
      print(f"Highest score: {max_score}")
      
      # Write summary
      with open('summary.txt', 'w') as f:
          f.write(f"Class Statistics\n")
          f.write(f"Average: {avg_score:.2f}\n")
          f.write(f"Maximum: {max_score}\n")
```

1. The task `generate_data` will generate a CSV-file `data.csv` with Python. 
1. The second task `analyze_data` will install Pandas to read from the previously generated CSV file (via `inputFiles` property) and find the average and maximum score.
1. Lastly, the second task will write the output into a `summary.txt` file.

The outputs will show both tasks and their respective `outputFiles`.




### Run Java Code in Kestra

Similar to Python, there are multiple ways available to run Java code.

#### Option 1: Simple Java (Compile & Run)

This flow compiles and runs Java directly in the container:

```yaml
id: java-hello-world
namespace: dev.testing

tasks:
  - id: run_java
    type: io.kestra.plugin.scripts.shell.Commands
    containerImage: eclipse-temurin:17-jdk
    commands:
      - |
        cat > HelloKestra.java << 'EOF'
        public class HelloKestra {
            public static void main(String[] args) {
                System.out.println("Hello from Java in Kestra!");
                System.out.println("Current time: " + java.time.LocalDateTime.now());
            }
        }
        EOF
      - javac HelloKestra.java
      - java HelloKestra
```

> [!IMPORTANT]
> Be aware that Java takes significantly longer than Python. So you may need to wait a few minutes. 

This easy way is using inline Java code which makes it not realistic for more than a quick testing. The code above will simply log 'Hello from Java in Kestra!' and the current time.

#### Option 2: Java with Namespace Files
Similar to Python, you can also create and maintain the Java code outside of the task and Flow with the help of Namespace files.

Here is how to do it:

1. In Kestra UI, go to your namespace (e.g. `dev.testing`) with: `Namespaces` > `dev` > `testing`.
1. Click on `Files`.
1. Create a file called `DataProcessor.java` and paste the following code:
```java
import java.io.*;
import java.util.*;

public class DataProcessor {
    public static void main(String[] args) throws IOException {
        // Read input
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "Diana");
        
        // Process data
        System.out.println("Processing " + names.size() + " records...");
        
        // Write output
        try (PrintWriter writer = new PrintWriter("output.txt")) {
            for (String name : names) {
                writer.println(name.toUpperCase());
            }
        }
        
        System.out.println("âœ“ Processing complete!");
        System.out.println("Output saved to output.txt");
    }
}
```

> [!NOTE]
> Again, you can nest files in structures with folders to improve maintainability.

4. Create a new flow that uses this namespace file:
```yaml
id: java-with-namespace-files
namespace: dev.testing

tasks:
  - id: compile_and_run
    type: io.kestra.plugin.scripts.shell.Commands
    containerImage: eclipse-temurin:17-jdk
    namespaceFiles:
      enabled: true
    outputFiles:
      - "output.txt"
    commands:
      - javac DataProcessor.java
      - java DataProcessor
      - cat output.txt
```

This code will write one line for each name to a file `output.txt`. 

#### Option 3: Maven Project

This option is great for production-grade systems since it allows to specify dependencies easily and create reproducible builds along many other benefits.

Here is what you need:

1. Create a file `pom.xml` in your Namespace files (see Option 2 for how to do this).
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>com.example</groupId>
    <artifactId>kestra-demo</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>
    
    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
            <version>2.10.1</version>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.13.0</version>
            </plugin>
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>exec-maven-plugin</artifactId>
                <version>3.5.0</version>
                <configuration>
                    <mainClass>com.example.MavenDataProcessor</mainClass>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```
2. Create a nested file `src/main/java/com/example/MavenDataProcessor.java` (you don't have to create each folder manually, you can create folders by using `/` in the filename).
```java
package com.example;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import java.io.*;
import java.util.*;

public class DataProcessor {
    
    public static void main(String[] args) throws IOException {
        System.out.println("Starting Data Processor...");
        
        // Create sample data
        List<Person> people = Arrays.asList(
            new Person("Alice", 25, "Engineering"),
            new Person("Bob", 30, "Sales"),
            new Person("Charlie", 35, "Marketing")
        );
        
        // Process data using external library (Gson)
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        String json = gson.toJson(people);
        
        // Write output
        try (PrintWriter writer = new PrintWriter("output.json")) {
            writer.println(json);
        }
        
        // Generate summary
        double avgAge = people.stream()
            .mapToInt(Person::getAge)
            .average()
            .orElse(0);
        
        System.out.println("âœ“ Processed " + people.size() + " records");
        System.out.println("âœ“ Average age: " + String.format("%.1f", avgAge));
        System.out.println("âœ“ Output saved to output.json");
    }
    
    static class Person {
        private String name;
        private int age;
        private String department;
        
        public Person(String name, int age, String department) {
            this.name = name;
            this.age = age;
            this.department = department;
        }
        
        public int getAge() { return age; }
    }
}
```
3. Create a new flow that uses the code:
```yaml
id: java-maven-project
namespace: dev.testing

tasks:
  - id: build_and_run
    type: io.kestra.plugin.scripts.shell.Commands
    containerImage: maven:3.9-eclipse-temurin-17
    namespaceFiles:
      enabled: true
    outputFiles:
      - "output.json"
    commands:
      - ls -la  # Debug: see what files are available
      - mvn --version  # Show Maven version
      - mvn clean compile  # Compile the project
      - mvn exec:java  # Run the main class
      - cat output.json  # Show the output
```

The code in this example will show several logs and ultimately save a `output.json` file with three people (name, age, department).


